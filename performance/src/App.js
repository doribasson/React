import React, { useState, useEffect, useMemo, useCallback } from "react";
import Child from "./Child";

function countIntial() {
  console.log("run function");
  return 4;
}

// const student = {
//   name: "dori",
//   age: "16"
// };

function App() {
  const [counter, setCounter] = useState(() => {
    return 4;
  });
  // const [counter, setCounter] = useState(4);
  // const [counter, setCounter] = useState(() => countIntial());
  const [student, setStudent] = useState({
    name: "dori",
    age: "16"
  });

  const increment = () => {
    setCounter(prev => prev + 1);
    console.log(student);
    student.name = "tsvi";
    console.log(student);

    setStudent({ ...student, name: "amir" });
    console.log(student);

    // console.log("increment");
  };

  // const decrement = () => {
  //   setCounter(prev => prev - 1);
  // };

  const decrement = useCallback(() => setCounter(prev => prev - 1), [counter]);
  //רק אם הקאונטר השתנה אז הוא יחשב מחדש את הפוקנציה.. לא מחזיר ערך רק מבצע שוב את הפונקציה.. זאת אומרת בגלל ששלחנו לילד את הפוקנציה הזאת שעושה שימוש ביוזקולבק אז הוא ייצר ויחשב אותה שוב רק אם הדפנדסי ביוזקולבק השתנה אם לא הוא לא יכנס יחשב מחדש את הפוקציה
  //אם הדפנדסי ריק אז הוא יבצע רק ביצירה הראשונה שלו וזהו

  return (
    <div className="App">
      {console.log(student)}
      <button onClick={increment}> + </button>
      <span> {counter} </span>
      <button onClick={decrement}> - </button>
      <Child str={"str"} decrement={decrement} />
      {/* <Child array={[1, 2, 3]} /> */}
      {/* <Child obj={{ name: "lol", age: "sdssd" }} /> */}
    </div>
  );
}

export default App;

//אפשר לדרוס או להוסיף לאובייקט שם האובייקט נקודה התכונה ולשנות את השם וזה יעבוד כי בעצם השם הוא וואליו ולא רפרנס אבל אם נרצה להעתיק את כל האווביקט אכשהו אז נצרך להעתיק אותו עם ספרד אופרטור.. כל הקטע שעושים סטסטייט סייטסטונד למשל ומשנים זה רק בשביל שנראה את השינוי אחרי בדום זאת אומרת שירנדר לנו לפי השינוי שעשינו. כי אם נעשה בלי הסט אז בעצם הוא ישנה אבל בגלל שלא עשינו רנדור לא נראה את השינוי. שינויים מתרנדרים רק עם עשינו סטסטייט או סייטפרופס
//כשעובדים עם רידקס אזהסטייט הוא אימיוטיבול זא לא ניתן לשינוי ולכן נצטרך לשנות אותו דרך העתקה עמוקה על ידיד ספרדאופרטור או על ידי אובגקטאסיין ואפשר גם על ידיד ספרייה שנקראת יימר ככה שאשפר לשנות רגיל בלי סט והוא אוטוטי מאחורי הקלעים יעשה את העבודה של העתקה עמוקה כמו הספראופטור.

//אם יש לנו קומפוננטה אבא ובתוכו קומפוננטה בן ברגע שנרנדר את האבא נראה שהוא ירנדר את הילד גם כי הוא בתוכו אבל ניתן למנוע את זה אם נעטוף בריאקט ממו את הקומפוננטה של הבן ועכשיו אם נשלח באבא דרך הילד סטיטים לבן או משתנים שהם פרמיטיבים כמו סטרינג או נמבר אז הוא לא ירנדר שוב אם הם לא ישתנו זאת אומרת הוא שמר את הערך שלהם ובדק אם הם השתנו אז תרנדר אם לא אז אל תרנדר.. עכשיו אם מדובר באובייקט או במערך אז ריאקט ממו לא יעזור ולכן נשתמש ביוז ממו ונעטוף את הפונקציה של המערך או האובייקט בזה ואד הוא ישמור בתוכו את את הערך ואז זה כן יעבוד אצל הבן זאת אומרת או לא ירנדרשוב אם יבין שהמערך או האבייקט לא השתנו כי הוא שומר אצלו בקש.. נשתמש בזה רק בפונקציות מורכבות שלוקחות הרבה זמן כמו למשל פיבונצי

//יוזקולבק בשונה מיוזמו הוא לא מחזיר וואליו ערך ושומר אותו בקש אלא הוא רק נועד לפונקציות שלא מחיזורות ערך ויודע אם ליצור ולהפעיל את הפונקציה או לא.. ברגע שנרשום יוזקולבק הוא בעצם ימנע רנדור שלו אם התוך הדפנדסי במערך הערך השתנה אם לא השתנה הוא ימנע רנדור ואם השתנה אז הוא ירנדר

//יוזקולבק זה בעצם מופנה לפונקציה למשל אם יש לי פונצקיה שמעלה בקאונטר ב 1 כל קליק באבא אז בבן אם נעביר לו את הפונקציה הזאת ונשתמש בה הוא ייצר בכל רנדור את הפונקציה הזאת מחדש וזה אנחנו לא רוצים לכן אנחנו נעטוף בקולבק את הפוקנציה הזאת באבא וזה ישמור בממורי את הפונקציה. בדפנדסי בתוך המערך של היוזקולבק נשים את הסטייט.. כל עוד הסטייט בדפנדסי לא השתנה אז הוא לא יחשב מחדש את הפוקנציה כל עוד הסטייט לא השתנה.. הוא ישתנה  רק אם הסטייט ישתנה ואז יעשה חישוב מחדש של הפונקציה
